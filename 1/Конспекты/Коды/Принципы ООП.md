# 1. Инкапсуляция 
 ``` python
 class BankAccount:
    def __init__(self, owner, initial_balance=0):
        self.owner = owner  # Публичный атрибут
        self.__balance = initial_balance  # Приватный атрибут (инкапсулированный)
    # Геттер для чтения баланса
    def get_balance(self):
        return self.__balance
    # Сеттер для изменения баланса с проверкой
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Внесено {amount}. Новый баланс: {self.__balance}")
        else:
            print("Сумма должна быть положительной.")
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Снято {amount}. Новый баланс: {self.__balance}")
        else:
            print("Недостаточно средств или неверная сумма.")
# Пример использования
account = BankAccount("Иван", 1000)
print(f"Владелец: {account.owner}")
print(f"Баланс: {account.get_balance()}")  # Доступ через геттер
account.deposit(500)  # Безопасное изменение через метод
account.withdraw(200)

print(account._BankAccount__balance)
  ```
# 2. Наследование
``` python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance
    def get_balance(self):
        return self.__balance
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Внесено {amount}. Баланс: {self.__balance}")
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Снято {amount}. Баланс: {self.__balance}")
class SavingsAccount(BankAccount):
    def __init__(self, owner, balance=0, rate=0.05):
        super().__init__(owner, balance)
        self.rate = rate
    def deposit(self, amount):
        super().deposit(amount)
        interest = amount * self.rate
        self._BankAccount__balance += interest
        print(f"Проценты: {interest}. Баланс: {self.get_balance()}")
    def apply_interest(self):
        interest = self.get_balance() * self.rate
        self._BankAccount__balance += interest
        print(f"Годовые проценты: {interest}. Баланс: {self.get_balance()}")

savings = SavingsAccount("Иван", 1000)
savings.deposit(500)
savings.apply_interest()
savings.withdraw(200)
```
# 3. Полиморфизм

``` python
            print(f"Внесено {amount}. Баланс: {self.__balance}")
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Снято {amount}. Баланс: {self.__balance}")
class SavingsAccount(BankAccount):
    def __init__(self, owner, balance=0, rate=0.05):
        super().__init__(owner, balance)
        self.rate = rate
    def deposit(self, amount):  # Переопределение для процентов
        super().deposit(amount)
        interest = amount * self.rate
        self._BankAccount__balance += interest
        print(f"Проценты: {interest}. Баланс: {self.get_balance()}")
class CheckingAccount(BankAccount):
    def __init__(self, owner, balance=0, fee=1):
        super().__init__(owner, balance)
        self.fee = fee
    def withdraw(self, amount):  # Переопределение для комиссии
        if 0 < amount <= self.__balance:
            self._BankAccount__balance -= amount + self.fee
            print(f"Снято {amount} + комиссия {self.fee}. Баланс: {self.get_balance()}")
# Функция, демонстрирующая полиморфизм
def process_transaction(account, amount, action):
    if action == "deposit":
        account.deposit(amount)
    elif action == "withdraw":
        account.withdraw(amount)
# Пример использования
savings = SavingsAccount("Иван", 1000)
checking = CheckingAccount("Мария", 1000)
print("Сберегательный счет:")
process_transaction(savings, 500, "deposit")  # Полиморфизм: deposit с процентами
print("\nТекущий счет:")
process_transaction(checking, 200, "withdraw")  # Полиморфизм: withdraw с комиссией
 ```